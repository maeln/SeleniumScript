/*
 * generated by Xtext 2.10.0
 */
package emn.fil.a3.generator

import java.io.File
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import emn.fil.a3.seleniumScript.Script
import emn.fil.a3.seleniumScript.Function
import emn.fil.a3.seleniumScript.Selectors
import emn.fil.a3.seleniumScript.Selector
import org.eclipse.emf.common.util.EList
import emn.fil.a3.seleniumScript.Expression
import emn.fil.a3.seleniumScript.PropSelector

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SeleniumScriptGenerator extends AbstractGenerator {
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
       fsa.generateFile('SeleniumTest.java',
           // resource.allContents.toIterable.filter(Calendar).head.generateCalendar
           resource.contents.filter(Script).head.genSeleniumcript
       )
   }
	
	def CharSequence genSeleniumcript(Script script) '''
		class Script {
			public static void main(String args[]) throws InterruptedException {
				System.setProperty("webdriver.gecko.driver", "TO FILL");
				WebDriver driver;
				
				
				«FOR f : script.functions»
					«switch f.name {
						case "open":
							genOpen(f)
						case "go":
							genGo(f)
						case "click":
							genClick(f)
						case "fill":
							genFill(f)
					}»
				«ENDFOR»
			}
		}
	'''
	
	def CharSequence genOpen(Function f) '''
		«IF f.params.get(0).equals("firefox")»
			driver = new FirefoxDriver()
		«ELSE»
			throw new RuntimeException("Unsuported browser.");
		«ENDIF»
	'''
	
	def CharSequence genGo(Function f) '''
		driver.get("«f.params.get(0)»");
	'''
	
	def CharSequence genClick(Function f) '''
		«IF f.params.get(0) instanceof Selectors»
		driver.findElement(«f.params»).click();
		«ELSE»
			throw new RuntimeException("Unknown expression.");
		«ENDIF»
	'''
	
	def getXpathFromSelectors(EList<Expression> expressions) {
		var firstParam = expressions.get(0);
		if(firstParam instanceof Selectors) {
			var selectors = (firstParam as Selectors).selectors
			var paths = selectors.map[s |
				var props = getXPathFromProps(s.propSelectors);
				switch s.name {
					case "field" : '''
						input[ @type="text" and «props»]
					'''
					case "button" :'''
						button[«props»] |
						input[ (@type="button" or @type="submit" or @type="reset" «props»
					'''
					
					case "checkbox" :'''
						input[ @type="checkbox" and «props»]
					'''
					case "link" :'''
						a[ «props»]
					'''
					
					case "select" :'''
						select[ «props»]
					'''
					
				}
			]
		} else throw new IllegalArgumentException("Selector Needed")
	}
	
	def getXPathFromProps(EList<PropSelector> props) {
		"TODO"
	}
	
	def CharSequence genFill(Function f) '''
	'''
	
	def CharSequence genXPath(Selector s) '''
	
	'''
}
